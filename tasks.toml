[config]
on_error_task = "docker_teardown"


[env]
POSTGRES_URL = "postgres://root:password@localhost:5433/postgres"
DB_URL = "postgres://root:password@localhost:5433/testdb"
DB_NAME = "testdb"
DB_USER = "root"
DB_PASSWORD = "password"
RUSTC_WRAPPER="sccache"
CARGO_MAKE_COVERAGE_PROVIDER = "kcov"

[tasks.format]
install_crate = "rustfmt"
command = "cargo"
args = ["fmt", "--", "--emit=files"]

[tasks.clean]
command = "cargo"
args = ["clean"]

[tasks.build]
command = "cargo"
args = ["build"]
dependencies = ["clean"]

[tasks.test]
command = "cargo"
args = ["test"]
dependencies = ["clean"]

[tasks.test-flow]
dependencies = [
    "docker_setup",
    "test_setup",
    "test",
    "docker_teardown",
]

[tasks.food-flow]
dependencies = [
    "format",
    "build",
    "test-flow"
]


[tasks.docker_setup]
command = "docker"
args = [
        "run",
        "-d",
        "-e",
        "POSTGRES_USER=${DB_USER}",
        "-e",
        "POSTGRES_PASSWORD=${DB_PASSWORD}",
        "-e",
        "POSTGRES_DB=${DB_NAME}",
        "-p",
        "5433:5432",
        "--name",
        "testdb",
        "postgres:13.0-alpine"
]

[tasks.test_setup]
script_runner = "@rust"
script = [
'''
//! ```cargo
//! [dependencies]
//! diesel = { version = "1.4.5", features = ["postgres"] }
//! diesel_migrations = "1.4.0"

extern crate diesel;
extern crate diesel_migrations;

use diesel::prelude::*;
use diesel::pg::PgConnection;
use diesel_migrations::run_pending_migrations;
use std::env;

fn main() {
    let db_url = env::var("DB_URL").expect("Unable to retrieve DB_URL");
    let conn =
        PgConnection::establish(&db_url).expect("Could not connect to database on test run, exiting");

    run_pending_migrations(&conn).expect("Could not run migrations, exiting");

    let query = diesel::sql_query("INSERT INTO ingredients (id, name, description) VALUES
        ('390bf411-1aa7-48f4-a6fc-d161e0ddf63c', 'cheese', 'something'),
        ('9489cca0-3e7a-4571-9b58-96a4e3fe3e55', 'ham', 'something'),
        ('bdeb204f-c85e-4883-9ca4-4061f2624268', 'pickles', 'something'),
        ('fb2c63f7-ac81-4abc-9e5f-8744202aeabc', 'tomato', 'something')
    ");

    query
        .execute(&conn)
        .expect("Could not seed database, exiting");
}
'''
]

[tasks.test_teardown]
script_runner = "@rust"
script = [
'''
//! ```cargo
//! [dependencies]
//! diesel = { version = "1.4.5", features = ["postgres"] }
extern crate diesel;

use diesel::prelude::*;
use diesel::pg::PgConnection;
use std::env;

fn main() {
    let postgres_url = env::var("POSTGRES_URL").expect("Unable to retrieve DB_URL");
    let conn =
        PgConnection::establish(&postgres_url).expect("Could not connect to database, exiting");


    let query = diesel::sql_query("DROP DATABASE IF EXISTS testdb WITH (FORCE)");

    query
        .execute(&conn)
        .expect("Failure dropping database testdb, exiting");
}
'''
]

[tasks.docker_teardown]
command = "docker"
args = ["rm", "-f", "testdb"]

